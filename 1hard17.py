f = open('17_hard.txt')  # открытие файла
m = [int(i) for i in f]  # создание массива со всеми числами в файле

# функция поиска кол-во делителей числа
def dil(x):
    x = abs(x)  # обязательно брать модуль числа, так как диапозон будет до корня числа
    dilit = []  # массив с делителями
    for d in range(1, int(x ** 0.5) + 1):  # берем до корня числа чтобы программа считала быстрее
        if x % d == 0:  # если делитель делится нацело на число
            dilit.append(d)  # добавление в массив делителя
            dilit.append(x // d)  # добавление в массив обратного делителя так как мы брали до корня числа
    m_dil = set(dilit)  # важное удаление дубликатов делителей
                        # например если число 121 в массиве будут числа [1, 11, 11, 121]
                        # благодаря множеству это будет выглядеть так {1,11, 121}
    return len(m_dil)  # возвращение длины множества, что и является количеством делителей


elems = set()  # множество элементов с одинаковыми цифрами
for n in m:  # перебор всех чисел из файла, которые содержатся в массиве m
    n = str(n)  # перевод числа в строку
    for j in n:  # перебор каждого символа в числе
        count = n.count(j)  # количество этого символа
        if count == 2:  # если количество является 2
            elems.add(int(n))  # добавление в множество числа в тип int
max_elem = max(elems)  # максимальный элемент в множестве

min_para = []  # массив с минимальными элементами из пары
result = []  # массив с суммой модулей элементами пары

for i in range(len(m) - 1):  # цикл перебора пар начинается с 0 до длины массива m уменьшеннего на 1
    e1 = m[i]  # первый элемент пары
    e2 = m[i + 1]  # второй элемент пары
    if dil(e1) == dil(e2):  # проверка на равное количество делителей
        if e1 * e2 > 0:  # являются ли числа с одинаковым знаком
                         # при умножении чисел с одинаковым знаком всегда будет число положительное
                         # это и проверяем
           if abs(e1) + abs(e2) < max_elem:  # проверка условия с макс элементом
                result.append(abs(e1) + abs(e2))  # добавление в массив суммы модулей
                min_para.append(min(e1, e2))  # добавление в массив минимального элемента пары

# сортировка массивов
result.sort()
min_para.sort()

sr_znach = int(sum(result) / len(result))  # для нахождения ср.знач надо всю сумму поделить на количество
                                           # sum(result) - сумма всех значений, len(result) - количество значений

print(sr_znach, min(min_para))  # вывод ответа
# возможная запись print(sr_znach, min_para[0])